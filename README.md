1.	int* ptr - &var;
-	EN: This is a declaration of an integer-type pointer (ptr), a variable, which stores an actual memory address. This address points to a cell/place in memory, at which the value of a int-type variable, named ‘var’, is stored
•	E.g: Buying directly from a producer or via a reseller
-	BG: Това е фрагмент от код, което показва декларацията на указател ptr към целочислена променлива var. Стойността на ptr е адрес на клетка от паметта, в която се държи стойността на променливата var. По този начин можем да работим или манипулираме индиректно стойността на var, указвайки какво да правим с данните, намиращи се адреса, запазен в променливата ptr
•	Пример: Звънците (ptr) на домофонното табло на входната врата сигнализират по същия начин, както и тези (var) на входните врати на апартаментите във входа
2.	while(condition/s){directives and other conditions – if-statements, etc} … do{directives and other conditions}while(conditions)
-	EN: The body of a do-while cycle might be executed (if properly configured) at least once, compared to the pure ‘while’-cycle. This is possible due to the construction of ‘do-while’-statement, where directives (the ‘do’-part) are executed before checking the conditions (the while-part). Contrary, in ‘while’-statement, body is typically executed after condition(s) check. While(true){} is somehow an exception, depending on its logic
•	Like uncle Charlie says: “It is always better to ask for forgiveness than permission” – you’ll get what you want at least once
-	 BG:  При ‘while’-цикъл винаги първо проверяваме условие за изпълнение на тялото, докато при ‘do-while’ първо се минава през do-частта (директивите), след което се проверява условието в while()-частта.
•	Пример: Не обичаш да ядеш студена храна и бързаш да се нахраниш преди да изстине – дори и да е, ще хапнеш поне веднъж, преди да го установиш. В аналогичния случай с while, ще се взираш за пара, ще пипнеш с пръст,…
3.	for(int j = 1; j <= 5; j++) {std::cout << j << ‘ ‘;}
-	EN: for-cycles are usually used when we want to execute a particular code (the one between curly brakets) exact number of times (5 in our example). At first, the variable j (also can be considered a counter) is initialized (j = 0). This is done only at this point (once), followed by condition check (j < 5). If True, cycle-body (std::cout << j << ‘ ‘) is executed, followed by counter manipulation (j++ in this case. It could also be j--, j = j + 2, etc. – depending on what we want to do). Cycle body is executed as long as condition check returns True.
•	 E.g. Executing push-ups at series of 10
-	BG: Използваме for-цикъл, когато искаме да изпълним някакво действие определен брой пъти – в случая да отпечатаме на екрана всяка една итерация на цикъла. Започва с инициализация на променлива-брояч, която ще проверяваме на всяка итерация и ще изпълняваме действията от тялото на цикъла при съвпадение. След това стойността на променливата се сменя и се пристъпва към следващата итерация на цикъла
•	Напр: Пиене на лекарство по 3 пъти на ден
4.	Int CalculateSquare(int number) { int squareNumber = number * number; return squareNumber;}
Int main() {int number; std::cin >> number; std::cout << CalculateSquare(number);}
-	EN: If we happen to write the same block-code more than once, especially if it is a longer one, we could withdraw it in a separated function, away from main(). Then, we can call it and reuse it, instead of duplicating it, as many times as we need to (in main() ot other functions as well). Moreover, this potentially prevents form mistakes
-	BG: Използването на функции ни помага да оптимизираме кода, като избегнем потенциални повторения на фрагменти, които изпълняват сходна функция – събиране на две числа, проверка в календара, отпечатване на едно и също съобщение. Чрез функциите тези фрагменти се отделят от останалия код и се извикват при необходимост
5.	Memory management is crucial for operation and performance. Adaptive mechanisms and optimizations exist to deal with huge structures of data. In C++(as well as in other languages), different types of memory are used for different data types. Stack memory is where primitive data types are stored – int, double, char, predefined arrays and some strings. Larger and dynamic data structures are stored in heap memory. Contrary to stack, it can be (re)allocated dynamically (e.g. when resizing vectors, etc.), as well as deallocated in the end of execution.
-	BG: Паметта се дели на две части – stack-памет и heap-памет. Първата се използва за съхранение на примитивните типове от данни – целочислени, плаващи-запетаи, масиви с известен размер. Втората е предвидена за по-сложни структури от данни изискващи не само голям обем от нея, но и възможността за допълнително заделяне при необходимост, както и механизми за освобождаването й, след приключване на работата по тях.
