1.	int* ptr - &var;
-	EN: This is a declaration of an integer-type pointer (ptr), a variable, which stores an actual memory address. This address points to a cell/place in memory, at which the value of a int-type variable, named ‘var’, is stored
•	E.g: Buying directly from a producer or via a reseller
-	BG: Това е фрагмент от код, което показва декларацията на указател ptr към целочислена променлива var. Стойността на ptr е адрес на клетка от паметта, в която се държи стойността на променливата var. По този начин можем да работим или манипулираме индиректно стойността на var, указвайки какво да правим с данните, намиращи се адреса, запазен в променливата ptr
•	Пример: Звънците (ptr) на домофонното табло на входната врата сигнализират по същия начин, както и тези (var) на входните врати на апартаментите във входа
2.	while(condition/s){directives and other conditions – if-statements, etc} … do{directives and other conditions}while(conditions)
-	EN: The body of a do-while cycle might be executed (if properly configured) at least once, compared to the pure ‘while’-cycle. This is possible due to the construction of ‘do-while’-statement, where directives (the ‘do’-part) are executed before checking the conditions (the while-part). Contrary, in ‘while’-statement, body is typically executed after condition(s) check. While(true){} is somehow an exception, depending on its logic.
•	E.g: Like uncle Charlie says: “It is always better to ask for forgiveness than permission” – you’ll get what you want at least once
-	 BG:  При ‘while’-цикъл винаги първо проверяваме условие за изпълнение на тялото, докато при ‘do-while’ първо се минава през do-частта (директивите), след което се проверява условието в while()-частта.
•	Пример: Не обичаш да ядеш студена храна и бързаш да се нахраниш преди да изстине – дори и да е, ще хапнеш поне веднъж, преди да го установиш. В аналогичния случай с while, ще се взираш за пара, ще пипнеш с пръст,…
3.	for(int j = 1; j <= 5; j++) {std::cout << j << ‘ ‘;}
-	EN: for-cycles are usually used when we want to execute a particular code (the one between curly brakets) exact number of times (5 in our example). At first, the variable j (also can be considered a counter) is initialized (j = 0). This is done only at this point (once), followed by condition check (j < 5). If True, cycle-body (std::cout << j << ‘ ‘) is executed, followed by counter manipulation (j++ in this case. It could also be j--, j = j + 2, etc. – depending on what we want to do). Cycle body is executed as long as condition check returns True.
•	 E.g. Executing push-ups at series of 10
-	BG: Използваме for-цикъл, когато искаме да изпълним някакво действие определен брой пъти – в случая да отпечатаме на екрана всяка една итерация на цикъла. Започва с инициализация на променлива-брояч, която ще проверяваме на всяка итерация и ще изпълняваме действията от тялото на цикъла при съвпадение. След това стойността на променливата се сменя и се пристъпва към следващата итерация на цикъла
•	Напр: Пиене на лекарство по 3 пъти на ден
4.	Int CalculateSquare(int number) { int squareNumber = number * number; return squareNumber;}
Int main() {int number; std::cin >> number; std::cout << CalculateSquare(number);}
-	EN: If we happen to write the same block-code more than once, especially if it is a longer one, we could withdraw it in a separated function, away from main(). Then, we can call it and reuse it, instead of duplicating it, as many times as we need to (in main() ot other functions as well). Moreover, this potentially prevents form mistakes
-	BG: Използването на функции ни помага да оптимизираме кода, като избегнем потенциални повторения на фрагменти, които изпълняват сходна функция – събиране на две числа, проверка в календара, отпечатване на едно и също съобщение. Чрез функциите тези фрагменти се отделят от останалия код и се извикват при необходимост
5.	Memory management is crucial for operation and performance. Adaptive mechanisms and optimizations exist to deal with huge structures of data. In C++(as well as in other languages), different types of memory are used for different data types. Stack memory is where primitive data types are stored – int, double, char, predefined arrays and some strings. Larger and dynamic data structures are stored in heap memory. Contrary to stack, it can be (re)allocated dynamically (e.g. when resizing vectors, etc.), as well as deallocated in the end of execution.
-	BG: Паметта се дели на две части – stack-памет и heap-памет. Първата се използва за съхранение на примитивните типове от данни – целочислени, плаващи-запетаи, масиви с известен размер. Втората е предвидена за по-сложни структури от данни изискващи не само голям обем от нея, но и възможността за допълнително заделяне при необходимост, както и механизми за освобождаването й, след приключване на работата по тях.
6.	In C++, Encapsulation is a method (not to be mistaken with actual C++ methods/functions) for protecting a Class’ members from direct intervention, coming from outside the Class. This is achieved by using the so-called ‘access-modifiers’ - private and public. Actually, by default, a Class’ members are all private, meaning they couldn’t be reached directly from outside the Class itself. By restricting the access to these members, we are avoiding possible unwanted changes  in Class’ logic and purpose. On top of that, encapsulation still gives us a way to reach a member, as well as to change its current value or logic. This is achieved by using the so-called Get- and Set-methods (Getters and Setters) which can GET the value of a member or SET it to something else. As they are not standardized, we have to make them public, in order to use them from outside the class. In addition, using the words get/set in their name is recommended, because it facilitates us when reading the code.
•	E.g. A modern TV-set gives us the possibility to change an enormous bunch of its settings (lately, mainly through its remote-control) or provide info (through its ‘info’-button) or additional service(e.g. VoD). These are typical SET- and GET-methods which allow changing settings and reaching maximum utilization of appliance’s extras without messing with its low-level embedded logic.
-	Енкапсулацията в С++ е способ, който дава възможност да ограничим външния достъп до атрибутите на даден клас, докато, едновременно с това, позволява да се променят стойностите на някои от полетата му (в зависимост от предназначението им). Това става чрез т.нар. модификатори на достъпа – публичен и частен/служебен. По подразбиране всички членове на даден клас са служебни – т.е. защитени са от външна намеса. Дава ни се възможност или да ги направим публични (чрез public:), или да осигурим достъп до всеки един от тях за четене (чрез GET-метод), или за промяна(чрез SET-методи). GET/SET са специфични нестандартизирани методи, които ние сами трябва да реализираме, в зависимост от това до какво от класа какъв достъп евентуално искаме да предоставим.
•	Напр: В автомобил, показанието на скоростомера е GET-метод (но логиката, по която тази инфо стига но нас е недостъпна за манипулиране), а натискането/отпускането на педала на газта е SET-метод, чрез който ни се позволява да променяме скоростта. Това обаче не ни позволява да променяме принципа на подаване на гориво към двигателя, неговата работа, задвижването на колелата и пр.
•	Пак в автомобил – индикаторът на горивото също е GET-метод, ориентировъчно показващ количеството му в резервоара. Нямаме обаче достъп до датчика в него и не можем да променим показанието на таблото. Всъщност, насилствено можем, но това няма да увеличи/намали горивото в резервоара. Индиректно обаче можем, като налеем допълнително гориво на бензиностанцията (или като ни го източат нощем под изгорялата улична лампа), което е SET-метод, чрез който осигуряваме на автомобила ресурс да изпълнява предназначението си.
7.	Throwing an exception, translated from C++ian means “generating an error message”. It is most often caused by semantic or syntax mistakes in code, causing compile-time or run-time errors.   
8.	Vectors are STL-containers, that can store elements of same data type (int only, or string only, class…). Their size is not constant, as it may shrink or expand, depending on pulling in or pulling out elements.
-	BG: Векторът е линейна структура от данни от STL-библиотеката. Използват се за съхранение на променливи/обекти от един и същ тип.
9.	References are variables, created as aliases for other variables. Pointers are variables, that contain the memory address of other variables. Although similar in action, pointers are more flexible than references. An advantage of pointers over references is that pointers can be reassigned, whereas references can not:
int number1 = 1;
int number2 = 2;
int* ptr;
ptr = &number1;
ptr = &number2;
int &rfr = number1;
int &rfr = number2;	// this row will throw an exception for multiple declaration
10.	
